<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Super Boss Rush Extreme</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#05060b;--fg:#e9f6ff;--accent:#ff6b6b;--muted:#7b8a99}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  #wrap{display:flex;gap:14px;padding:14px}
  canvas{background:linear-gradient(180deg,#021018 0%, #04121a 100%);border-radius:8px;box-shadow:0 8px 26px rgba(0,0,0,.7)}
  #ui{width:300px}
  .panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:12px}
  .bar{height:12px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#ffb57b)}
  button{padding:8px 12px;border-radius:8px;background:#0b2636;border:1px solid rgba(255,255,255,0.03);color:var(--fg);cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  h3{margin:4px 0 8px}
  .kbd{display:inline-block;padding:4px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-family:monospace}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c" width="960" height="560"></canvas>
  <div id="ui">
    <div class="panel">
      <h3>Super Boss Rush Extreme</h3>
      <div class="muted" id="roundInfo">Super Round 1 — Mag Flux Destroyer</div>
      <div style="height:8px"></div>
      <div class="muted">Player Health</div>
      <div class="bar" style="margin-top:6px"><i id="playerHP" style="width:100%"></i></div>
      <div style="height:8px"></div>
      <div class="muted">Boss Health</div>
      <div class="bar" style="margin-top:6px"><i id="bossHP" style="width:100%"></i></div>
      <div style="height:8px"></div>
      <div class="muted" id="weaponInfo"><span class="kbd">GUN</span> — Space to fire, <span class="kbd">A</span> to toggle</div>
    </div>

    <div class="panel">
      <div class="muted">Controls</div>
      <div style="height:8px"></div>
      <div class="muted">Move: Arrow keys or WASD</div>
      <div class="muted">Shoot / Attack: Space</div>
      <div class="muted">Switch Weapon: <span class="kbd">A</span></div>
      <div style="height:8px"></div>
      <button id="restart">Restart</button>
    </div>

    <div class="panel">
      <div class="muted">Notes</div>
      <ul class="muted">
        <li>Mag Flux Destroyer is brutal: stay mobile and use sword to clear close blades carefully</li>
        <li>Blades wind up before firing (1.25s) — watch the glow</li>
        <li>Super attack locks blades onto the player for 10s — blades fire faster; their shots are slower but hit much harder</li>
        <li>Blades cannot be destroyed; they have a chance to block your attacks on contact</li>
      </ul>
    </div>
  </div>
</div>

<script>
// Super Boss Rush Extreme - single boss: Mag Flux Destroyer (updated)

// Canvas & input
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let keys = {};
addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return Math.random()*(max-min)+min; }
function distP(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }
function angleBetween(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }

let player, boss, bullets, lastTime, shootTimer;
bullets = [];

// Player
function createPlayer(){
  return {
    x: W/2, y: H - 90, r: 12,
    speed: 280, hp: 120, maxHp:120,
    weapon: 'gun', shootCooldown: 0.14, swordCooldown:0, swordActiveUntil:0, swordSwingTime:0.22, _aLock:false
  };
}

// bullet helper
function spawnBullet(x,y,vx,vy, owner='enemy', opts={}){
  bullets.push(Object.assign({x,y,vx,vy,r:opts.r||4,owner,dmg:opts.dmg||8,life:opts.life||5}, opts));
}

// Mag Flux Destroyer definition (stronger blades, super modified)
const MagFlux = {
  name: "Mag Flux Destroyer",
  maxHp: 1400,
  enter(self){
    self.hp = self.maxHp;
    self.timer = 0;
    self.x = W/2; self.y = 160;
    // blades orbit data
    self.blades = []; // {a, r, angSpeed, state, windup, targetAngle, fired}
    self.bladeCount = 10;
    for (let i=0;i<self.bladeCount;i++){
      const a = i*(Math.PI*2/self.bladeCount) + rand(-0.2,0.2);
      self.blades.push({
        a,
        r: 64 + (i%2?12: -6),
        angSpeed: 1.2 + Math.random()*0.8, // faster base spin
        state: 'orbit', // 'orbit' | 'windup' | 'firing' | 'return' | 'orbitPlayer'
        windup: 0,
        targetAngle: a,
        fired: false
      });
    }
    self.aimTimer = 4.8; // blades pick targets often
    self.superReady = true;
    self.superActive = false;
    self.superTimer = 0;
    self.superDuration = 10; // seconds
    // blade behavior tuning
    self.bladeFireChance = 0.32; // chance each blade begins windup when aimTimer fires
    self.bladeBlockChance = 0.65; // chance blade blocks player's attack on contact
  },

  update(self, dt){
    self.timer += dt;
    // Aim window: blades may wind up more often due to higher base chance
    self.aimTimer -= dt;
    if (self.aimTimer <= 0){
      self.aimTimer = 3.8 + Math.random()*1.0; // faster windows
      for (const b of self.blades){
        if (b.state === 'orbit' && Math.random() < self.bladeFireChance){
          b.state = 'windup';
          b.windup = 1.25;
          const bx = self.x + Math.cos(b.a)*b.r;
          const by = self.y + Math.sin(b.a)*b.r;
          b.targetAngle = Math.atan2(player.y - by, player.x - bx);
          b.fired = false;
        }
      }
    }

    // Super trigger when hp below 60%
    if (!self.superActive && self.superReady && self.hp <= self.maxHp * 0.60){
      self.superActive = true;
      self.superReady = false;
      self.superTimer = self.superDuration;
      // blades reposition to orbit the player and spin very fast
      for (const b of self.blades){
        b.state = 'orbitPlayer';
        // distribute around player
        b.a = Math.random()*Math.PI*2;
        b.r = 110 + rand(-16,16);
        b.angSpeed = 9.2 + Math.random()*3.0; // very fast spin
        b.windup = 0;
        b.fired = false;
      }
    }

    // Super active logic: blades attack way faster, their projectiles are slower but deal more damage
    if (self.superActive){
      self.superTimer -= dt;
      if (self.superTimer <= 0){
        // end super: blades return to boss orbit and slow down
        self.superActive = false;
        for (const b of self.blades){
          b.state = 'return';
          b.targetAngle = Math.random()*Math.PI*2;
          b.angSpeed = 1.0 + Math.random()*0.6;
          b.r = 64 + rand(-8,8);
        }
      } else {
        // during super: high fire rate
        for (const b of self.blades){
          // rotate around player
          b.a += b.angSpeed * dt;
          const bx = player.x + Math.cos(b.a) * b.r;
          const by = player.y + Math.sin(b.a) * b.r;
          // fire often: we use a random chance per frame scaled so overall rate is very high
          if (Math.random() < 0.36 * dt * 60){ // tuned to make frequent shots
            // slower projectile but much more damage
            const ang = Math.atan2(player.y - by, player.x - bx);
            spawnBullet(bx, by, Math.cos(ang)*90 + rand(-10,10), Math.sin(ang)*90 + rand(-10,10), 'enemy', {r:10, dmg:36, life:6});
          }
        }
        return; // skip normal processing while super active
      }
    }

    // Normal operation: update blade states (orbit, windup, firing, return)
    for (const b of self.blades){
      if (b.state === 'orbit' || b.state === 'return'){
        b.a += b.angSpeed * dt;
        if (b.state === 'return'){
          b.r += (64 - b.r) * (2.0 * dt);
          if (Math.abs(b.r - 64) < 6) b.state = 'orbit';
        }
      } else if (b.state === 'windup'){
        b.a += (b.angSpeed * 0.6) * dt;
        b.windup -= dt;
        if (b.windup <= 0){
          // fire faster than before
          b.state = 'firing';
          const bx = self.x + Math.cos(b.a) * b.r;
          const by = self.y + Math.sin(b.a) * b.r;
          const ang = Math.atan2(player.y - by, player.x - bx);
          // produce a faster volley (increased rate), individual shot speed increased
          spawnBullet(bx, by, Math.cos(ang)*520 + rand(-24,24), Math.sin(ang)*520 + rand(-24,24), 'enemy', {r:6, dmg:18, life:3.2});
          // chance to immediate follow-up shot
          if (Math.random() < 0.4) spawnBullet(bx, by, Math.cos(ang+0.06)*460, Math.sin(ang+0.06)*460, 'enemy', {r:5,dmg:14,life:3.0});
          // go back to return/orbit
          b.state = 'return';
          b.angSpeed = 1.0 + Math.random()*0.6;
        }
      } else if (b.state === 'firing'){
        b.state = 'return';
      }
    }
  },

  draw(self, ctx){
    // draw core
    ctx.save();
    ctx.translate(self.x, self.y);
    ctx.fillStyle = '#b84dff';
    ctx.beginPath(); ctx.arc(0,0,48,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = '12px system-ui'; ctx.fillText('Mag Flux Destroyer', -56, 74);
    ctx.restore();

    // draw blades
    for (const b of self.blades){
      let bx, by;
      if (self.superActive || b.state === 'orbitPlayer'){
        bx = player.x + Math.cos(b.a) * b.r;
        by = player.y + Math.sin(b.a) * b.r;
      } else {
        bx = self.x + Math.cos(b.a) * b.r;
        by = self.y + Math.sin(b.a) * b.r;
      }

      // blade visual with stronger glow when windup or super
      ctx.save();
      ctx.translate(bx, by);
      if (b.state === 'windup'){
        ctx.fillStyle = 'rgba(255,200,80,0.96)';
        ctx.beginPath(); ctx.arc(0,0,16 + Math.sin(performance.now()/120)*2,0,Math.PI*2); ctx.fill();
      } else if (self.superActive){
        ctx.fillStyle = 'rgba(255,160,90,0.9)';
        ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#ffb86b';
      ctx.beginPath(); ctx.ellipse(0,0,10,20, b.a + 0.5, 0, Math.PI*2); ctx.fill();
      // tiny shield rim to visually indicate block chance
      ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }
  },

  onHit(self, dmg){
    // core takes full damage; blades cannot be broken by attacks now
    self.hp -= dmg;
    if (self.hp < 0) self.hp = 0;
  }
};

// Game init and loop
function startGame(){
  player = createPlayer();
  bullets = [];
  boss = Object.assign({}, MagFlux);
  boss.enter(boss);
  lastTime = performance.now();
  shootTimer = 0;
  updateUI();
  requestAnimationFrame(loop);
}

// player update & input
function updatePlayer(dt){
  let dx = (keys['arrowright'] || keys['d'] ? 1:0) - (keys['arrowleft'] || keys['a'] ? 1:0);
  let dy = (keys['arrowdown'] || keys['s'] ? 1:0) - (keys['arrowup'] || keys['w'] ? 1:0);
  const len = Math.hypot(dx,dy) || 1;
  player.x += (dx/len) * player.speed * dt;
  player.y += (dy/len) * player.speed * dt;
  player.x = clamp(player.x, 20, W-20);
  player.y = clamp(player.y, 100, H-20);

  // toggle weapon on literal 'a' press (short press)
  if (keys['a'] && !player._aLock){
    player._aLock = true;
    player.weapon = (player.weapon === 'gun') ? 'sword' : 'gun';
    document.getElementById('weaponInfo').innerHTML = player.weapon === 'gun' ? '<span class="kbd">GUN</span> — Range: Long; Fire: Space' : '<span class="kbd">SWORD</span> — Range: Short; Fire: Space';
  }
  if (!keys['a']) player._aLock = false;

  // firing
  shootTimer -= dt;
  player.swordCooldown -= dt;
  const space = keys[' '] || keys['space'];
  if (player.weapon === 'gun'){
    if (space && shootTimer <= 0){
      shootTimer = player.shootCooldown;
      spawnBullet(player.x, player.y-14, 0, -520, 'player', {r:4, dmg:12, life:1.0});
      spawnBullet(player.x-8, player.y-10, -80, -420, 'player', {r:3, dmg:8, life:1.0});
      spawnBullet(player.x+8, player.y-10, 80, -420, 'player', {r:3, dmg:8, life:1.0});
    }
  } else {
    if (space && player.swordCooldown <= 0){
      player.swordCooldown = 0.45;
      player.swordActiveUntil = performance.now()/1000 + player.swordSwingTime;
      performSwordHit();
    }
  }
}

// sword hit logic with blade block chance
function performSwordHit(){
  const swingRadius = 72;
  const swingArc = Math.PI * 0.9;
  const aim = angleBetween(player, boss);
  // check each blade first: if sword arc intersects a blade, blade may block the attack
  for (const b of boss.blades){
    let bx = (boss.superActive || b.state==='orbitPlayer') ? player.x + Math.cos(b.a)*b.r : boss.x + Math.cos(b.a)*b.r;
    let by = (boss.superActive || b.state==='orbitPlayer') ? player.y + Math.sin(b.a)*b.r : boss.y + Math.sin(b.a)*b.r;
    const dpb = distP(player.x, player.y, bx, by);
    if (dpb <= swingRadius + 18){
      // blade is within sword arc range: roll for block
      if (Math.random() < boss.bladeBlockChance){
        // blocked: create small spark effect (visual only) and cancel further processing
        // do not damage core or blade
        return;
      }
      // else fall through to allow sword to hit core
    }
  }

  // if not blocked by blades, damage core if within range/arc
  const aToBoss = Math.atan2(boss.y - player.y, boss.x - player.x);
  let delta = Math.abs(((aToBoss - aim + Math.PI) % (Math.PI*2)) - Math.PI);
  const d = Math.hypot(boss.x - player.x, boss.y - player.y);
  if (delta <= swingArc/2 && d <= swingRadius + 48){
    boss.onHit(boss, 36); // heavy sword damage
    updateUI();
  }
}

// bullets update, collisions, blade blocking logic
function updateBullets(dt){
  for (let i = bullets.length-1; i >= 0; i--){
    const b = bullets[i];

    // move
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt;

    // remove if expired
    if (b.life <= 0 || b.x < -80 || b.x > W+80 || b.y < -120 || b.y > H+120){
      bullets.splice(i,1);
      continue;
    }

    if (b.owner === 'enemy'){
      // hit player
      if (Math.hypot(b.x - player.x, b.y - player.y) < b.r + player.r){
        player.hp -= b.dmg;
        bullets.splice(i,1);
        updateUI();
        continue;
      }
    } else {
      // player bullet can be blocked by blades: check proximity to each blade; blades now unbreakable
      let blocked = false;
      for (const blade of boss.blades){
        const bx = (boss.superActive || blade.state==='orbitPlayer') ? player.x + Math.cos(blade.a)*blade.r : boss.x + Math.cos(blade.a)*blade.r;
        const by = (boss.superActive || blade.state==='orbitPlayer') ? player.y + Math.sin(blade.a)*blade.r : boss.y + Math.sin(blade.a)*blade.r;
        if (Math.hypot(b.x - bx, b.y - by) < b.r + 12){
          // blade near bullet: chance to block
          if (Math.random() < boss.bladeBlockChance){
            // blocked: consume bullet and show tiny spark (visual only)
            bullets.splice(i,1);
            blocked = true;
            break;
          } else {
            // not blocked -> bullet continues and may hit core
            // we intentionally do not destroy blade
          }
        }
      }
      if (blocked) continue;

      // if not blocked, check hit on core
      if (Math.hypot(b.x - boss.x, b.y - boss.y) < b.r + 48){
        boss.onHit(boss, b.dmg);
        bullets.splice(i,1);
        updateUI();
        continue;
      }
    }
  }
}

// render
function render(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#02121a'; ctx.fillRect(0,0,W,H);

  // header
  ctx.fillStyle = '#dff7ff'; ctx.font = '18px system-ui';
  ctx.fillText(`Super Round — ${MagFlux.name}`, 12, 26);

  // draw boss and blades
  boss.draw(boss, ctx);

  // draw bullets
  for (const b of bullets){
    ctx.beginPath();
    if (b.owner === 'player'){ ctx.fillStyle = '#9be7ff'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    else { ctx.fillStyle = '#ff9b71'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
  }

  // draw player
  ctx.save(); ctx.translate(player.x, player.y);
  ctx.fillStyle = '#7cf2a3'; ctx.beginPath(); ctx.arc(0,0,player.r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#0f2030'; ctx.beginPath(); ctx.arc(0, -4, 6, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // sword visual arc
  const now = performance.now()/1000;
  if (player.weapon === 'sword' && player.swordActiveUntil > now){
    const aim = angleBetween(player, boss);
    const swingRadius = 72;
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = 'rgba(255,230,180,0.18)';
    ctx.beginPath();
    const start = aim - Math.PI*0.45;
    const end = aim + Math.PI*0.45;
    ctx.moveTo(0,0);
    ctx.arc(0,0,swingRadius,start,end);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // HUD
  ctx.fillStyle = '#fff'; ctx.font = '13px system-ui';
  ctx.fillText(`HP ${Math.max(0,player.hp|0)} / ${player.maxHp}`, 12, H-12);
  ctx.fillText(`${boss.name}`, W - 220, 28);
}

// UI update
function updateUI(){
  document.getElementById('playerHP').style.width = `${Math.max(0, player.hp)/player.maxHp*100}%`;
  document.getElementById('bossHP').style.width = `${Math.max(0, boss.hp)/boss.maxHp*100}%`;
  document.getElementById('weaponInfo').innerHTML = player.weapon === 'gun' ? '<span class="kbd">GUN</span> — Range: Long; Fire: Space' : '<span class="kbd">SWORD</span> — Range: Short; Fire: Space';
}

// main loop
function loop(time){
  const dt = Math.min((time - (lastTime||time))/1000, 0.033);
  lastTime = time;
  // update
  updatePlayer(dt);
  boss.update(boss, dt);
  updateBullets(dt);

  // victory / defeat checks
  if (boss.hp <= 0){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#02121a'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '28px system-ui';
    ctx.fillText('YOU DEFEATED MAG FLUX DESTROYER', 80, H/2);
    return;
  }
  if (player.hp <= 0){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#02121a'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '28px system-ui';
    ctx.fillText('GAME OVER', W/2 - 90, H/2);
    return;
  }

  render();
  requestAnimationFrame(loop);
}

// restart hook
document.getElementById('restart').addEventListener('click', ()=> startGame());

// start
startGame();

</script>
</body>
</html>
